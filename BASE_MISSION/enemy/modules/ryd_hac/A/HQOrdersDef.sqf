if ((RydHQ_DefDone) and (RydHQ_Order == "DEFEND") and not ((RydHQ_LastE == 0) and ((count RydHQ_KnEnemies) > 0) and (RydHQ_FirstEMark))) exitwith {RydHQ_Done = true; diag_log "Exiting HQ Orders Def"};if (RydHQ_Order == "DEFEND") then 	{	RydHQ_DefDone = true;	RydHQ_NewOrders = true;	sleep 1.1;	RydHQ_NewOrders = false;	};if ((RydHQ_FirstEMark) and (RydHQ_LastE == 0) and ((count RydHQ_KnEnemies) > 0)) then {RydHQ_FirstEMark = false};_spotsN = (count (RydHQ_reconG + RydHQ_FOG + RydHQ_snipersG)) * 2;_default = [];_Epos0 = [];_Epos1 = [];if (isNil ("RydHQ_Obj")) then 	{	if not (isNull leaderHQ) then 		{		_default = position leaderHQ		}	else 		{		_default = position (leader (RydHQ_Friends select (random (floor (count RydHQ_Friends)))))		}	} else 	{	_default = position RydHQ_Obj	};if not ((count RydHQ_KnEnPos) == 0) then 	{		{		_Epos0 = _Epos0 + [(_x select 0)];		_Epos1 = _Epos1 + [(_x select 1)]		}	foreach RydHQ_KnEnPos	}else	{	if not (isNull leaderHQ) then 		{		_Epos0 = [(position leaderHQ) select 0];		_Epos1 = [(position leaderHQ) select 1]		}	else 		{		_Epos0 = [(position (leader (RydHQ_Friends select (random (floor (count RydHQ_Friends)))))) select 0];		_Epos1 = [(position (leader (RydHQ_Friends select (random (floor (count RydHQ_Friends)))))) select 1]		}	};	if (RydHQ_Debug) then {		diag_log format ["MSO-%1 HETMAN: HQ issuing orders to defend position at %2, known enemy positions %3", time, mapgridposition _default, count RydHQ_KnEnPos];};_Epos0Max = _default select 0;_Epos0Min = _default select 0;for [{_a = 0},{_a < (count _Epos0)},{_a = _a + 1}] do 	{	_EposA = _Epos0 select _a;	if (_a == 0) then {_Epos0Min = _EposA};	if (_a == 0) then {_Epos0Max = _EposA};	if (_Epos0Min >= _EposA) then {_Epos0Min = _EposA};	if (_Epos0Max < _EposA) then {_Epos0Max = _EposA};	};_Epos1Max = _default select 1;_Epos1Min = _default select 1;_sel1Max = 1;_sel1Min = 1;for [{_b = 0},{_b < (count _Epos1)},{_b = _b + 1}] do 	{	_EposB = _Epos1 select _b;	if (_b == 0) then {_Epos1Min = _EposB};	if (_b == 0) then {_Epos1Max = _EposB};	if (_Epos1Min >= _EposB) then {_Epos1Min = _EposB};	if (_Epos1Max < _EposB) then {_Epos1Max = _EposB};	};_PosMid0 = (_Epos0Min + _Epos0Max)/2;_PosMid1 = (_Epos1Min + _Epos1Max)/2;_dX = (_PosMid0) - ((getPos leaderHQ) select 0);_dY = (_Posmid1) - ((getPos leaderHQ) select 1);RydHQ_Angle = 0;RydHQ_Angle = _dX atan2 _dY;if (RydHQ_Angle < 0) then {RydHQ_Angle = RydHQ_Angle + 360}; _dXb = 200 * (sin RydHQ_Angle);_dYb = 200 * (cos RydHQ_Angle);_posX = ((getPos leaderHQ) select 0) + _dXb;_posY = ((getPos leaderHQ) select 1) + _dYb;_PrimDir = "";_SecDir = "";switch true do	{	case ((RydHQ_Angle < 30) or (RydHQ_Angle >= 330)) : {_PrimDir = "N"};	case ((RydHQ_Angle >= 30) and (RydHQ_Angle < 60)) : {_PrimDir = "N";_SecDir = "E"};	case ((RydHQ_Angle >= 60) and (RydHQ_Angle < 120)) : {_PrimDir = "E"};	case ((RydHQ_Angle >= 120) and (RydHQ_Angle < 150)) : {_PrimDir = "S";_SecDir = "E"};	case ((RydHQ_Angle >= 150) and (RydHQ_Angle < 210)) : {_PrimDir = "S"};	case ((RydHQ_Angle >= 210) and (RydHQ_Angle < 240)) : {_PrimDir = "S";_SecDir = "W"};	case ((RydHQ_Angle >= 240) and (RydHQ_Angle < 300)) : {_PrimDir = "W"};	case ((RydHQ_Angle >= 300) and (RydHQ_Angle < 330)) : {_PrimDir = "N";_SecDir = "W"};	};_Lenght = 1000;_Width = 200;if (((RydHQ_Angle >= 45) and (RydHQ_Angle < 135)) or ((RydHQ_Angle >= 225) and (RydHQ_Angle < 315))) then {_Lenght = 200;_Width = 1000};_FreeLOS = 320;_randomPrimDir = ["N","S","W","E"];_randomSecDir = ["W","E"];_Center = [_posX,_posY];if (((_Center distance [_PosMid0,_PosMid1]) < 500) or ((count RydHQ_KnEnPos) == 0)) then 	{	_Lenght = 450;	_Width = 450;	_PrimDir = _randomPrimDir select (floor (random (count _randomPrimDir)));	if (((_PrimDir == "N") or (_PrimDir == "S")) and ((random 100) >= 50)) then {_SecDir = _randomSecDir select (floor (random (count _randomSecDir)))} else {_SecDir = ""};	switch true do		{		case ((_PrimDir == "N") and (_SecDir == "")) : {RydHQ_Angle = 0};		case ((_PrimDir == "N") and (_SecDir == "E")) : {RydHQ_Angle = 45};		case ((_PrimDir == "E") and (_SecDir == "")) : {RydHQ_Angle = 90};		case ((_PrimDir == "S") and (_SecDir == "E")) : {RydHQ_Angle = 135};		case ((_PrimDir == "S") and (_SecDir == "")) : {RydHQ_Angle = 180};		case ((_PrimDir == "S") and (_SecDir == "W")) : {RydHQ_Angle = 225};		case ((_PrimDir == "W") and (_SecDir == "")) : {RydHQ_Angle = 270};		case ((_PrimDir == "N") and (_SecDir == "W")) : {RydHQ_Angle = 315};		default {RydHQ_Angle = random 360};		};	};if ((_Center distance [_PosMid0,_PosMid1]) < 500) then {_Center = position leaderHQ};if (RydHQ_Debug) then 	{	_i = "Center";	_markerposition = _Center; 	_markercolor = "ColorGreen";	_markershape = "ICON"; 	_markertype = "DOT"; 	_markertext = "Def Center"; _marker = [_i, _markerposition, _markershape, [1,1], "COLOR:", _markercolor,"TEXT:",_markertext,"TYPE:",_markertype, "GLOBAL"] call CBA_fnc_createMarker;	};nul = [_spotsN,_PrimDir,_SecDir,_FreeLOS,_Lenght,_Width,_Center] execVM (RYD_HAC_PATH + "A\Spotscan.sqf");_Spot = [];_GS = [];RydHQ_RecDefSpot = [];waituntil {sleep 1;RydHQ_SpotsScan};		{	if ((count RydHQ_GoodSpots) == 0) exitwith {};	_aa = 0;	for [{_a = 0},{_a < (count RydHQ_GoodSpots)},{_a = _a + 1}] do 		{		_GS = RydHQ_GoodSpots select _a;		if (_a == 0) then {_Spot = _GS;_aa = 0};		if ((_Spot distance (vehicle (leader _x))) > (_GS distance (vehicle (leader _x)))) then {_Spot = _GS;_aa = _a};		};	RydHQ_Roger = false;	RydHQ_GoodSpots set [_aa,0]; 	RydHQ_GoodSpots = RydHQ_GoodSpots - [0];	sleep 1.1;	nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDefRecon.sqf");	waituntil {sleep 1.5;RydHQ_Roger};	RydHQ_RecDefSpot = RydHQ_RecDefSpot + [_x];	if ((count RydHQ_GoodSpots) == 0) exitwith {};	}foreach (RydHQ_reconG + RydHQ_FOG + RydHQ_snipersG);RydHQ_GoodSpots = [];RydHQ_Def = [];_LMCU = RydHQ_Friends - (RydHQ_AirG + RydHQ_NavalG + RydHQ_StaticG + RydHQ_SupportG + RydHQ_ArtG + (RydHQ_NCCargoG - (RydHQ_Friends - (RydHQ_AirG + RydHQ_NavalG + RydHQ_StaticG + RydHQ_SupportG + RydHQ_ArtG))));switch (random 100 >= (50/(0.5 + RydHQ_Fineness))) do	{	case true : 		{		switch true do			{			case (_PrimDir == "N") : {_PrimDir = "S"};			case ((_PrimDir == "N") and (_SecDir == "E")) : {_PrimDir = "S";_SecDir = "W"};			case (_PrimDir == "E") : {_PrimDir = "W"};			case ((_PrimDir == "S") and (_SecDir == "E")) : {_PrimDir = "N";_SecDir = "W"};			case (_PrimDir == "S") : {_PrimDir = "N"};			case ((_PrimDir == "S") and (_SecDir == "W")) : {_PrimDir = "N";_SecDir = "E"};			case (_PrimDir == "W") : {_PrimDir = "E"};			case ((_PrimDir == "N") and (_SecDir == "W")) : {_PrimDir = "S";_SecDir = "E"};			};				_spotsN = (count _LMCU) * 1.5;		nul = [_spotsN,_PrimDir,_SecDir,_FreeLOS,_Lenght,_Width,_Center] execVM (RYD_HAC_PATH + "A\Spotscan.sqf");		_Spot = [];		RydHQ_DefSpot = [];		waituntil {sleep 1;RydHQ_SpotsScan};						{			if ((count RydHQ_GoodSpots) == 0) exitwith {};			_bb = 0;			for [{_b = 0},{_b < (count RydHQ_GoodSpots)},{_b = _b + 1}] do 				{				_GS = RydHQ_GoodSpots select _b;				if (_b == 0) then {_Spot = _GS;_bb = 0};				if ((_Spot distance (vehicle (leader _x))) > (_GS distance (vehicle (leader _x)))) then {_Spot = _GS;_bb = _b};				};			RydHQ_Roger = false;			RydHQ_GoodSpots set [_bb,0]; 			RydHQ_GoodSpots = RydHQ_GoodSpots - [0];			sleep 1.1;			nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDef.sqf");			waituntil {sleep 1.5;RydHQ_Roger};			RydHQ_DefSpot = RydHQ_DefSpot + [_x];			if ((count RydHQ_GoodSpots) == 0) exitwith {};			}		foreach _LMCU - RydHQ_RecDefSpot;		RydHQ_GoodSpots = [];		while {(count RydHQ_AirG > 0)} do			{				{				RydHQ_Roger = false;				_x setVariable [("Busy" + (str _x)), false, true];				nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDefAir.sqf");				waituntil {sleep 1.1;RydHQ_Roger};				}			foreach RydHQ_AirG;			};			{			_position = [((position leaderHQ) select 0) + random 500 - random 500,((position leaderHQ) select 1)+ random 500 - random 500];			_radius = 100;			_precision = 20;			_sourcesCount = 1;			_expression = "Meadow";			switch true do 				{				case (_x in RydHQ_InantryG) : {_expression = "(1 + (2 * Houses)) * (1 + (1.5 * Forest)) * (1 + Trees) * (1 - Meadow)"};				case (not (_x in RydHQ_InantryG)) : {_expression = "(1 + (2 * Meadow)) * (1 - Forest) * (1 - (0.5 * Trees))"};				_Spot = selectBestPlaces [_position,_radius,_expression,_precision,_sourcesCount];				_Spot = _Spot select 0;				_Spot = _Spot select 0;				};			RydHQ_Roger = false;			nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDef.sqf");			waituntil {sleep 1.1;RydHQ_Roger};			RydHQ_Def = RydHQ_Def + [_x];			}		foreach (_LMCU - (RydHQ_DefSpot + RydHQ_RecDefSpot))		};	case false : 		{			{			_position = [((position leaderHQ) select 0) + random 500 - random 500,((position leaderHQ) select 1)+ random 500 - random 500];			_radius = 100;			_precision = 20;			_sourcesCount = 1;			_expression = "Meadow";			switch (true) do 				{				case (_x in RydHQ_InantryG) : {_expression = "(1 + (2 * Houses)) * (1 + (1.5 * Forest)) * (1 + Trees) * (1 - Meadow)"};				case (not (_x in RydHQ_InantryG)) : {_expression = "(1 + (2 * Meadow)) * (1 - Forest) * (1 - (0.5 * Trees))"};				};			_Spot = selectBestPlaces [_position,_radius,_expression,_precision,_sourcesCount];			_Spot = _Spot select 0;			_Spot = _Spot select 0;			RydHQ_Roger = false;			nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDef.sqf");			waituntil {sleep 1.1;RydHQ_Roger};			RydHQ_Def = RydHQ_Def + [_x];			}		foreach _LMCU - RydHQ_RecDefSpot;		while {(count RydHQ_AirG > 0)} do			{				{				RydHQ_Roger = false;				_x setVariable [("Busy" + (str _x)), false, true];				nul = [_x,_Spot] execVM (RYD_HAC_PATH + "A\GoDefAir.sqf");				waituntil {sleep 1.1;RydHQ_Roger};				}			foreach RydHQ_AirG;			};		};	};RydHQ_Done = true;